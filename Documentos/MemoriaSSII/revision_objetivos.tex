
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage[spanish,activeacute]{babel}
%\author{Juan Rodr\'\i guez Hortal\'a, Javier G\'omez Santos, Roberto Torres de Alba}
\title{Revisi\'on final}
\frenchspacing
\begin{document}
\maketitle
\tableofcontents
\section{Evaluaci\'on de objetivos}
La finalidad de esta secci\'on es revisa los objetivos que en su d\'\i a fueron propuestos para GENARO, y revisar cuales de ellos han sido cumplidos, cuales no, y cuales han sido alcanzados s\'olo en parte.

\subsection{Objetivos principales}

\subsubsection{Componer una canci\'on para un tempo, tonalidad, escala y duraci\'on aproximada}

GENARO es capaz de usar estos par\'ametros para generar una canci\'on, a excepci\'on de la tonalidad, para la que nos hemos restringido a tonalidades mayores. Esto es lo que quer\'\i amos obtener con GENARO.

\subsubsection{Posibilidad de reproducir la m\'usica generada a trav\'es de nuestro programa}

Con la ayuda de un programa auxiliar llamado \emph{Timidity}, que es invocado de manera transparente al usuario, somos capaces de reproducir la m\'usica que genarmos a trav\'es de nuestro programa.

\subsubsection{Exportar la m\'usica generada a formatos .wav y .midi}

A trav\'es de las librerias de \emph{Haskore} GENARO crea un midi con la m\'usica que ha compuesto. Este midi puede ser exportado a un fichero .wav mediante la ayuda del \emph{Timidity}, que es invocado nuevamente por el programa principal.

\subsubsection{Interfaz gr\'afica amigable}

El interfaz gr\'afico facilita de manera intuitiva un control absoluto sobre los par\'ametros de uso de GENARO a un usuario. Act\'ua como nexo ante los dem\'as programas para facilitar al usuario el uso de GENARO.

\subsection{Objetivos secundarios}

\subsubsection{Generar un archivo pdf o ps con la partitura del instrumento elegido}
Objetivo no cumplido. Por problemas de tiempo, de dificultad en el uso de Lilypond y en la traducci\'on
del tipo \emph{Music} de \emph{Haskore} no se ha podido introducir adecuadamente en Genaro. Hay algo
hecho pero no es definitivo.

\subsubsection{Edici\'on de la estructura de la canci\'on especificando para cada secci\'on musical su tipo de escala y tonalidad, su tempo y otros atributos}
Como hemos dicho los parametros de escala, tempo y tonalidad estan establecidos para la canci\'on completa sin que se puedan cambiar en secciones individuales. Sin embargo cada seccion musical tiene propios parametros en funcion del tipo de pista que s\'\i ~que se guardan y se editan separadamente.

\subsubsection {Poder seleccionar qu\'e instrumentos se silencian y cu\'ales no para poder o\'\i r y exportar en \emph{.wav} cada parte por separado}

Objetivo cumplido. Tanto cada secci\'on musical como cada pista se pueden silenciar para que no se tengan
en cuenta en la exportaci\'on a .wav.

\subsubsection{Incorporar un editor de patrones r\'\i tmicos y otro de secuencias de acordes, y la posibilidad de salvarlos en ficheros. Posibilidad de elegir qu\'e patrones y secuencias se van a considerar en la generaci\'on de la m\'usica}
Objetivo cumplido. Se desarrollo un editor de patrones r\'\i tmicos independiente del interfaz principal, a diferencia del editor de secuencias de acordes (llamado progresi\'on) que s\'\i ~est\'a ligado al interfaz principal.

\subsubsection{Posibilidad de introducir una melod\'\i a por medio de la interfaz para que nuestro generador la armonice y componga un r\'\i tmo para ella}
No est\'a implementado del todo. Existe la posibilidad de armonizar una melod\'\i a generada por GENARO 
pero no la posibilidad de introducir una melod\'\i a por el interfaz. No ser\'\i a muy dif\'\i cil a~nadirlo ya que tenemos formularios para crear editores de pianola.

\subsubsection{Sistema de comandos: se podr\'a invocar al programa a trav\'es de la consola con distintos par\'ametros, ofreciendo acceso a las mismas funcionalidades que la interfaz gr\'afica. El objetivo de esto es facilitar la reutilizaci\'on del software}
Definitivamente no esta implementado ni se pretendi\'o implementarlo. Se le dio menos prioridad que el resto
de las tareas ya que se refer\'\i a a versatilidad de uso y no a las propias funciones de GENARO. Por falta
de tiempo y debido a que su implementaci\'on ser\'\i a bastante complicada no se hizo.


\section{Ampliaciones posibles}

Considerando el estado actual del proyecto, GENARO podr\'\i a continuar avanzando en varios puntos. Aqu\'\i ~intentaremos enumerarlas, pero es muy recomendable acudir a los cap'itulos correspondientes a cada m'odulo para obtener una descripci'on m'as precisa y concreta de sus posibles ampliaciones.

\subsection{Bater\'\i a}

Enlazar la bater\'\i a a GENARO, e introduciendole aleatoriedad.

\subsection{Patrones R\'\i tmicos}

Introducir patrones r\'\i tmicos din\'amicos y aleatorios.

\subsection {Acordes}

Introducci\'on de otras tonalidades y ritmos

\subsection {Editor de pianola}

Permitir ligar las notas de una misma voz, y crear un editor de pianola espec\'\i fico para la melod\'\i a.

\subsection {Interfaz principal}

Pulir el interfaz para que goce de mayor intuitividad, y a\~nadirle las opciones de borrar pistas y bloques.

\subsection {Compositores para otras texturas}

A parte de la ya implementada melod\'ia acompa\~nada, compositores para otros estilos como fugas, canon, y en general estructuras con reglas muy r\'\i gidas.

\section{Evoluci\'on del proyecto}
Al inicio del proyecto no se ten'ian muchas ideas claras como es l'ogico. Pero si que hab'ia un par de intenciones bastante decididas:
        \begin{enumerate}
        \item Conseguir un compositor autom'atico: la idea era que Genaro fuera un programa que apretando un bot'on compusiera una obra completa y coherente. No se hab'ian fijado los instrumentos pero las ideas del trio de Jazz y el reparto de funciones r'itmicas, mel'odicas y arm'onicas ya se hab'ian tomado como punto de partida. 
        \item Emplear Sicstus Prolog para los algortimos de generaci'on de m'usica: el primer problema de generaci'on de m'usica que se abord'o fue el de la generaci'on de progresiones de acordes, porque la m'usica en Genaro siempre se abord'o desde la perspectiva de la melod'ia acompa~nada, y de la melod'ia compuesta como una improvisaci'on sobre una base de acompa~namiento, otra vez bas'andose en conceptos del Jazz. 
\newline
La generaci'on de progresiones es el primer paso para la generaci'on de acompan~amientos porque est'a a un grado de abstracci'on m'as elevado que la m'usica concreta, y permite definir el entorno musical o contexto arm'onico que caracteriza un fragmento musical, con lo que se pueden utilizar las progresiones para componer a partir de ellas otros fragmentos musicales que se reproduzcan a la vez que el acompa~namiento, como el bajo y la melod'ia. Adem'as tiene la ventaja de estar bastante bien formalizada por las reglas de la armon'ia lo que hace bastante f'acil dise~nar algoritmos que generen progresiones de acordes.
        \item La interfaz se implementar'ia mediante un lenguaje imperativo.
        \end{enumerate}

Seg'un fue evolucionando el proyecto y fuimos desarrollando nuestras ideas modificamos nuestra opini'on respecto a las cuestiones anteriores:
        \begin{itemize}
        \item Pasamos de pensar en un compositor autom'atico a pensar en un asistente a la composici'on: Genaro tendr'ia que ser un programa interactivo para ser m'as 'util, liberando al compositor de tareas repetitivas (como el enlace de las voces, o la edici'on manual de archivos midi), pudiendo trabajar a niveles de abstracci'on m'as altos como el de las progresiones de acordes o los patrones r'itmicos. Tambi'en pensando en el compositor amateur, que no sabe demasiado de armon'ia y que podr'ia aprender a trav'es de Genaro, o simplemente en un m'usico que tiene un encargada la composici'on de una pieza de m'usica electr'onica y quiere plasmar r'apidamente sus ideas, o recibir inspiraci'on o ideas nuevas de Genaro, ideas que luego puede desarrollar de forma coherente utilizando su experiencia humana.
        \item Abandonar Sicstus por SWI-Prolog y Haskell: en un primer momento se pens'o en utilizar Sicstus Prolog porque se preted'ia abordar la generaci'on de acordes como la formalizaci'on de una serie de restricciones sobre las progresiones, basadas en las reglas de la armon'ia, y que luego Prolog se ocupara de todo con sus b'usquedas. Cuando empezamos a comprender como funcionaban las restricciones nos dimos cuenta de que era m'as f'acil y m'as natural, tambi'en por las propias reglas de la armon'ia, dise~nar el generador de acordes como un programa que mutara progresiones.
\newline
Se continu'o usando Prolog por inercia y tambi'en por su alto grado de abstracci'on, que facilitaba centrarse en los algoritmos y pasar m'as f'acilmente el tr'amite de la implementaci'on. Y lleg'o el momento de generar los archivos midi, el producto final de Genaro, para las progresiones de acordes primigenias, enlazando las voces siempre igual y aplicando siempre el mismo tipo de ritmo (el concepto de patr'on r'itmico a'un no estaba desarrollado). Para ello se estudi'o el estandar midi y se definieron predicados que formalizaran una representaci'on intermedia de la m'usica, entre las progresiones y el midi. Se llegaron a definir dos representaciones de este tipo. La idea era que Prolog escribiera un archivo de texto con el formato de una de esas representaciones intermedias y que C++ leyera ese archivo y generara el midi correspondiente. Tras muchos problemas con este enfoque se descubri'o la librer'ia Haskore de Haskell que ten'ia una tipo que representaba musicas y sobre todo funciones que converti'an elementos de ese tipo en archivos midi.
\newline
Durante un tiempo Haskell se emple'o solamente para el paso a midi, para lo que se definieron predicados para una representaci'on en Prolog similar a la del Haskore. El formato de las progresiones ya estaba establecido y es el que ha perdurado hasta ahora, a partir de terminos con ese formato se produci'an t'erminos en formato Prolog-Haskore con la primera versi'on del traductor de cifrados hecho en Prolog. Luego Haskell parseaba un fichero en ese formato y produc'ia el midi. El m'odulo de los patrones r'itmicos fue el primero que desarroll'o en Haskell desde un principio. La facilidad de uso, potencia y flexibilidad de Haskore hicieron que el m'odulo traductor de cifrados se migrara a Haskell, y que todos los m'odulo desarrollados despu'es (el de melod'ia, el de bajo y el de bater'ia) se desarrollaran en Haskell desde un principio. Tambi'en se desarroll'o en Haskell el armonizador, a trav'es del cu'al se articula la otra v'ia de generaci'on de progresiones de acordes.
\newline
Mientras tanto en el m'odulo de Prolog hubo cambios significativos. El hecho de que Genaro se enfocara ahora como una herramiento interactiva en vez de como un compositor independiente implicaba que la duraci'on de las progresiones se especificara de forma exacta, no aproximada como en las primeras versiones. Debido a este se modific'o la primera versi'on de la generaci'on de acordes, basada en la vuelta atr'as, en la que las mutaciones alargaban la progresi'on hasta lograr una longitud cercana a la especificada. A partir de esta versi'on antigua se lleg'o a la actual, en la que se fija exactamente la duraci'on de la progresi'on y luego se la muta respetando esta duraci'on. Este nuevo modelo de generaci'on de progresiones tambi'en facilit'o que se respetara el ritmo arm'onico.
\newline
Lo dif'icil en cuanto a algoritm'ia de generaci'on de m'usica en este proyecto fue empezar, porque una vez definida la abstracci'on del ritmo y el esp'iritu mutador de Genaro, y establecida la herramienta de trabajo que es Haskore todo fu'e m'as sencillo:
                \begin{itemize}
                \item la melod'ia recicla el concepto de patr'on r'itmico pas'andolo de dos dimensiones a una, y el concepto de mutaciones del generador de acordes (divide notas, junta notas), solo a~nade el concepto de curva mel'odica que es un cl'asico en los libros de armon'ia y teor'ia musical, no es nada nuevo. 
                \item el bajo comparte muchas caracter'isticas con la melod'ia, y sus algoritmos aprovechan muchas ideas de los de 'esta.
                \item La bater'ia es simplemente un acorde que siempre es el mismo (todas las piezas de la bater'ia sonando a la vez), al que se le aplica un patr'on r'itmico.
                \end{itemize}

En esta 'ultima fase del desarrollo de los algoritmos de genaraci'on m'usica hubo una cierta evoluci'on de las ideas iniciales en los casos de la melod'ia y del bajo:
                \begin{itemize}
                \item la melod'ia: En un principio con la primera versi'on de la melod'ia se devolv'ia la lista de acentos sin emplear. Esta se usaba como entrada para las funciones de mutaci'on. Pero despu'es de un tiempo nos dimos cuenta de que esa informaci'on estaba impl'icita en los silencios que forman parte de la melod'ia, as'i que se modificaron las funciones de mutaci'on para que trabajaran con listas de m'usica, algo mucho m'as sencillo y transparente.
                \item el bajo: Desde un principio se pens'o en hacer un bajo que implementara la t'ecnica del \emph{walking}, t'ecnica de composici'on de bajos del Jazz, que consiste en hacer que el bajo toque casi siempre notas de una misma duraci'on fijada, sin parar, y que vaya moviéndose por la escala dando saltos pequ~nos, `persiguiendo` a los acordes. Esa era la idea pero en un primer momento se hizo una versi'on tonta del bajo que para cada acorde siempre daba la misma nota, para que C++ tuviera una funci'on a la que llamar y no huniera que integrar a 'ultima hora. Esa funci'on deb'ia sobreescribirse con la definitiva, pero este bajista tonto gust'o a algunos desarrolladores y una versi'on suya modificada acab'o siendo el bajista Fundamentalista. El bajista Aphex surgi'o como un experimento de generaci'on que en parte fracas'o, porque fu'e un intento de hacer el bajista Walking sin trabajar demasiado. Pero como sonaba bonito se mantuvo y acab'o siendo un bajista bastate mel'odico, en ocasiones incluso m'as que la propia melod'ia. Y finalmente se desarroll'o el bajista Walking que s'i que es m'as o menos lo que se pens'o en un principio.
                \end{itemize}
 

        \item Interfaz: Se comenz'o haciendo en Java pero pronto se migr'o a Borland C++ por la facilidad de uso y potencia de sus librer'ias. En el caso del interfaz y del bucle principal lo dif'icil vino al final del proyecto. La decisi'on de hacer Genaro m'as interactivo supuso ampliar much'isimo el interfaz, que se llen'o de opciones, botones y rejillas, editores de patrones r'itmicos y de curvas mel'odicas...A lo que hay que sumar el trabajo de coordinar las llamadas entre lenguajes y a los programas externos, as'i como disen~ar la estructura de los proyectos de Genaro, que acabaron complic'andose bastante. As'i que pasamos de un interfaz casi simb'olico a un interfaz que ofrece much'isimas posibilidades de manipulaci'on haciendo Genaro mucho m'as 'util y divertido.
        \end{itemize}

Resumiendo, se pas'o de pensar en un compositor aut'onomo teniendo solamente claro unos esbozos de c'omo generar progresiones, a una herramienta interactiva que sirve como asistente a la composici'on, y que genera acompan~amientos, melod'ias y bajos, para cualquier n'umero de pistas y para una gran variedad de fuentes de sonido.

\end{document}
